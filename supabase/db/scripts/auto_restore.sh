#!/bin/bash

# This script automatically checks for backup files in the snapshot directory
# and restores the latest one if it exists.

# Only run if the database has been initialized (to avoid running during first-time setup)
if [ -f "${PGDATA}/PG_VERSION" ]; then
  echo "PostgreSQL data directory already exists, checking for backups to restore..."
  
  # Look for the latest backup in the snapshot directory
  if [ -d "/snapshot" ]; then
    LATEST_BACKUP=$(find /snapshot -name "backup_*.sql" -type f -printf "%T@ %p\n" | sort -n | tail -1 | cut -d' ' -f2)
    
    # If a backup file exists, restore it
    if [ -n "${LATEST_BACKUP}" ] && [ -f "${LATEST_BACKUP}" ]; then
      echo "Found backup file: ${LATEST_BACKUP}"
      echo "Preprocessing backup file to add IF NOT EXISTS clauses and fix ownership..."
      
      # Create a temporary directory for processed files
      TEMP_DIR=$(mktemp -d)
      PROCESSED_BACKUP="${TEMP_DIR}/processed_backup.sql"
      
      # Preprocess the backup file to add IF NOT EXISTS clauses and fix ownership
      cat "${LATEST_BACKUP}" | sed -E '
        # Add IF NOT EXISTS to CREATE TABLE statements
        s/CREATE TABLE public\.([a-zA-Z0-9_]+)/CREATE TABLE IF NOT EXISTS public.\1/g;
        
        # Replace OWNER TO postgres with OWNER TO current user
        s/OWNER TO postgres;/OWNER TO '"${POSTGRES_USER}"';/g;
        
        # Comment out primary key constraints (they are already defined in CREATE TABLE)
        s/ALTER TABLE ONLY public\.([a-zA-Z0-9_]+)[[:space:]]*\n[[:space:]]*ADD CONSTRAINT ([a-zA-Z0-9_]+) PRIMARY KEY \([^)]+\);/-- Primary key constraint \2 is already defined in CREATE TABLE\n-- ALTER TABLE ONLY public.\1\n--     ADD CONSTRAINT \2 PRIMARY KEY/g;
        
        # Comment out role creation statements (roles are already created by init.sql)
        s/^[[:space:]]*create role ([a-zA-Z0-9_]+).*nologin.*noinherit.*;/-- Role \1 is already created by init.sql/g;
        s/^[[:space:]]*create role ([a-zA-Z0-9_]+).*login.*noinherit.*;/-- Role \1 is already created by init.sql/g;
        s/^[[:space:]]*create role ([a-zA-Z0-9_]+).*nologin.*bypassrls.*;/-- Role \1 is already created by init.sql/g;
      ' > "${PROCESSED_BACKUP}"
      
      echo "Automatically restoring database from preprocessed backup..."
      
      # Use ON_ERROR_STOP=0 to continue despite errors
      # This allows the restore to complete even if some objects already exist
      psql -v ON_ERROR_STOP=0 -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" < "${PROCESSED_BACKUP}"
      
      # Clean up temporary files
      rm -rf "${TEMP_DIR}"
      
      # Verify and fix ownership issues
      echo "Checking and fixing ownership issues..."
      psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" <<EOF
-- Fix ownership of objects owned by postgres (if postgres role doesn't exist)
DO \$\$
BEGIN
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'postgres') THEN
    -- Change ownership of tables from postgres to current user
    DECLARE
      obj RECORD;
    BEGIN
      FOR obj IN SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tableowner = 'postgres'
      LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(obj.tablename) || ' OWNER TO "${POSTGRES_USER}"';
      END LOOP;
    END;
  END IF;
END
\$\$;
EOF
      
      # Verify critical tables exist
      echo "Verifying critical tables exist..."
      psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" <<EOF
-- Ensure llms table exists
CREATE TABLE IF NOT EXISTS public.llms (
  id bigint generated by default as identity not null,
  active boolean not null default false,
  vision boolean not null default false,
  content boolean not null default false,
  structured_content boolean not null default false,
  embeddings boolean not null default false,
  provider character varying not null,
  name character varying not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint llms_pkey primary key (id),
  constraint llms_id_key unique (id),
  constraint llms_name_key unique (name)
);

-- Insert default Ollama models (only if they don't exist)
DO \$\$
BEGIN
  IF NOT EXISTS (SELECT FROM public.llms WHERE name = 'mxbai-embed-large' AND provider = 'ollama') THEN
    INSERT INTO llms (name, provider, active, embeddings, content) VALUES
      ('mxbai-embed-large', 'ollama', true, true, false);
  END IF;
END
\$\$;

-- Ensure roles exist
DO \$\$
BEGIN
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'anon') THEN
    CREATE ROLE anon NOLOGIN NOINHERIT;
  END IF;
  
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'authenticated') THEN
    CREATE ROLE authenticated NOLOGIN NOINHERIT;
  END IF;
  
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'service_role') THEN
    CREATE ROLE service_role NOLOGIN NOINHERIT BYPASSRLS;
  END IF;
END
\$\$;
EOF
      
      echo "Database automatically restored successfully with error handling and verification."
    else
      echo "No backup files found in snapshot directory. Skipping automatic restore."
    fi
  else
    echo "Snapshot directory not found. Skipping automatic restore."
  fi
else
  echo "First-time PostgreSQL initialization - skipping automatic restore."
fi
